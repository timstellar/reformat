import os
# Импортируем Flask и SQLAlchemy
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

# --- 1. Настройка Flask приложения ---
# Создаем экземпляр Flask. Он нужен, чтобы SQLAlchemy знало,
# к какому приложению относятся настройки базы данных.
app = Flask(__name__)

# --- 2. Настройка ОДНОЙ Базы Данных ---
# Определяем путь к файлу нашей единственной базы данных SQLite.
# Мы назовем файл 'address_posts.db'.
# Он будет создан в той же папке, где находится этот скрипт.
basedir = os.path.abspath(os.path.dirname(__file__)) # Получаем путь к текущей папке
db_filename = 'address_posts.db'
db_path = os.path.join(basedir, db_filename)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + db_path

# Отключаем некритичную функцию отслеживания модификаций.
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

print(f"Путь к создаваемой базе данных: {db_path}") # Добавим вывод пути для ясности

# --- 3. Инициализация SQLAlchemy ---
# Создаем объект 'db'. Этот объект будет нашим основным инструментом
# для взаимодействия с базой данных (определение моделей, создание таблиц, запросы).
# Связываем его с нашим Flask-приложением 'app'.
db = SQLAlchemy(app)

# --- 4. Определение МОДЕЛИ (описание структуры таблицы) ---
# Вот ваш класс Posts с полем 'relative_address'.
# Ключевой момент: класс должен наследоваться от 'db.Model'.
# Это говорит SQLAlchemy, что данный класс описывает таблицу в базе данных.
class Posts(db.Model):
    # SQLAlchemy по умолчанию создаст таблицу с именем 'posts'
    # (имя класса в нижнем регистре).
    # Можно явно указать имя: __tablename__ = 'my_custom_posts_table'

    # Определяем колонку 'id':
    # db.Integer - тип данных "целое число".
    # primary_key=True - эта колонка является первичным ключом.
    # Первичный ключ уникально идентифицирует каждую строку в таблице.
    # Обычно СУБД сама заботится об автоинкременте для таких ключей.
    id = db.Column(db.Integer, primary_key=True)

    # Определяем колонку 'relative_address':
    # db.String(500) - тип данных "строка" с максимальной длиной 500 символов.
    # nullable=False - означает, что эта колонка НЕ МОЖЕТ содержать пустое значение (NULL).
    # При добавлении записи в таблицу нужно обязательно указать значение для 'relative_address'.
    relative_address = db.Column(db.String(500), nullable=False)

    # Необязательный метод для удобного представления объекта при отладке или выводе.
    def __repr__(self):
        return f'<Post ID: {self.id}, Address: {self.relative_address[:50]}...>'

# --- 5. Создание ТАБЛИЦЫ в файле Базы Данных ---
# Для выполнения операций с базой данных во Flask требуется "контекст приложения".
# Конструкция 'with app.app_context():' создает этот контекст на время выполнения блока кода.
with app.app_context():
    print(f"Подготовка к созданию таблицы 'posts' в базе данных...")

    # ОСНОВНАЯ КОМАНДА: db.create_all()
    # Эта команда делает следующее:
    # 1. Смотрит на все классы в вашем коде, которые унаследованы от db.Model (в нашем случае это только Posts).
    # 2. Проверяет, существует ли в базе данных (указанной в SQLALCHEMY_DATABASE_URI) таблица,
    #    соответствующая этой модели (в нашем случае таблица 'posts').
    # 3. Если таблицы НЕТ, она создает ее со всеми колонками, определенными в модели.
    # 4. Если таблица УЖЕ ЕСТЬ, команда НИЧЕГО не делает (она не удаляет и не изменяет существующие таблицы).
    db.create_all()

    print(f"Таблица 'posts' успешно создана (или уже существовала) в файле '{db_filename}'.")

print("Скрипт 'create_address_db.py' завершил работу.")

# --- (Конец кода в create_address_db.py) ---